<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="Siva Katamreddy">
<title>Introduction to Spring Boot</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Introduction to Spring Boot</h1>
<div class="details">
<span id="author" class="author">Siva Katamreddy</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction-to-spring-boot">1. Introduction to Spring Boot</a>
<ul class="sectlevel2">
<li><a href="#spring-boot-key-features">1.1. Spring Boot Key Features</a>
<ul class="sectlevel3">
<li><a href="#auto-configuration">1.1.1. Auto Configuration</a></li>
<li><a href="#convention-over-configuration">1.1.2. Convention Over Configuration</a></li>
<li><a href="#dependency-version-management">1.1.3. Dependency Version Management</a></li>
<li><a href="#production-ready-monitoring-capabilities">1.1.4. Production-Ready Monitoring Capabilities</a></li>
<li><a href="#embedded-servers-support">1.1.5. Embedded Servers Support</a></li>
<li><a href="#spring-ecosystem">1.1.6. Spring Ecosystem</a></li>
</ul>
</li>
<li><a href="#getting-started-with-spring-boot">1.2. Getting Started with Spring Boot</a></li>
<li><a href="#simple-rest-api-using-spring-boot">1.3. Simple REST API using Spring Boot</a></li>
<li><a href="#run-application-using-maven-and-gradle">1.4. Run Application using Maven and Gradle</a></li>
<li><a href="#run-application-as-fatjar">1.5. Run Application as FatJar</a></li>
<li><a href="#run-application-as-docker-container">1.6. Run Application as Docker Container</a></li>
<li><a href="#summary">1.7. Summary</a></li>
</ul>
</li>
<li><a href="#a-quick-tour-of-spring-framework-core-concepts">2. A Quick Tour of Spring Framework Core Concepts</a>
<ul class="sectlevel2">
<li><a href="#dependency-injection">2.1. Dependency Injection</a></li>
<li><a href="#bean-registration">2.2. Bean Registration</a>
<ul class="sectlevel3">
<li><a href="#annotation-based-configuration">2.2.1. Annotation-based Configuration</a></li>
<li><a href="#java-configuration">2.2.2. Java Configuration</a></li>
</ul>
</li>
<li><a href="#bean-scopes">2.3. Bean Scopes</a></li>
<li><a href="#bean-lifecycle-callbacks">2.4. Bean Lifecycle Callbacks</a></li>
<li><a href="#aspect-oriented-programming-aop">2.5. Aspect Oriented Programming (AOP)</a></li>
<li><a href="#summary-2">2.6. Summary</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This documentation is for version 0.0.1-SNAPSHOT.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction-to-spring-boot"><a class="anchor" href="#introduction-to-spring-boot"></a>1. Introduction to Spring Boot</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Spring Boot</strong> is the most popular framework for building applications in the Java world.
It is an <strong>Opinionated</strong> and <strong>Convention Over Configuration</strong> based approach to building Spring framework based applications.</p>
</div>
<div class="paragraph">
<p>Using Spring Boot, we can build different kinds of applications such as <strong>monolithic applications,
microservices, serverless applications, Batch processing applications</strong>, etc.</p>
</div>
<div class="paragraph">
<p>Let us take a quick look at what are the key features of Spring Boot that made it so popular.</p>
</div>
<div class="sect2">
<h3 id="spring-boot-key-features"><a class="anchor" href="#spring-boot-key-features"></a>1.1. Spring Boot Key Features</h3>
<div class="sect3">
<h4 id="auto-configuration"><a class="anchor" href="#auto-configuration"></a>1.1.1. Auto Configuration</h4>
<div class="paragraph">
<p>Spring Boot takes an opinionated view of the application and auto-configures various components(a.k.a beans)
based on the default conventions without requiring us to configure everything explicitly.
However, we can customize or override the bean configurations in various ways if required.</p>
</div>
<div class="paragraph">
<p>For example, if we add <code>spring-boot-starter-data-jpa</code> starter then <strong>Hibernate</strong> dependencies will be added as
the JPA implementation because it is the most commonly used JPA provider.
Also, Spring Boot tries to auto-configure the components required for using Spring Data Jpa
such as <code>DataSource</code>, <code>EntityManagerFactory</code>, <code>PlatformTransactionManager</code> etc.
If there is an in-memory JDBC driver in the classpath like <strong>H2</strong> or <strong>HSQL</strong> then Spring Boot
will auto-configure the <strong>DataSource</strong> with in-memory settings.</p>
</div>
<div class="paragraph">
<p>If we want to use any non in-memory databases like <strong>MySQL</strong>, <strong>Postgresql</strong> etc then
we can add the respective JDBC driver jar and configure the JDBC connection parameters
in <code>application.properties</code> file. Then Spring Boot will use those properties to configure
<code>DataSource</code> bean as opposed to using default in-memory database.
We can even configure a DataSource bean by ourselves using <code>@Bean</code> annotation then
Spring Boot will backoff and use the <code>DataSource</code> bean configured by us instead of auto-configuring it.</p>
</div>
<div class="paragraph">
<p>With Spring Boot&#8217;s auto-configuration, the complexity of configuring a Spring application is greatly simplified.</p>
</div>
</div>
<div class="sect3">
<h4 id="convention-over-configuration"><a class="anchor" href="#convention-over-configuration"></a>1.1.2. Convention Over Configuration</h4>
<div class="paragraph">
<p>Spring Boot relies upon various default conventions so that it can auto-configure the application.</p>
</div>
<div class="paragraph">
<p>For example, in plain Spring based applications, we use configuration properties
by registering the <code>PropertySourcesPlaceholderConfigurer</code> bean.
In Spring Boot application, we can put our configuration properties in <code>src/main/resources/application.properties</code> file
and Spring Boot will automatically register <code>PropertySourcesPlaceholderConfigurer</code> bean loading
the properties from that file. We don&#8217;t have to explicitly specify the properties file name.</p>
</div>
<div class="paragraph">
<p>Similarly, we might want to configure different values for properties based on the environment
(<strong>dev, qa, staging, prod</strong>) our application is running. We can configure our configuration properties in
<code>application-{profile}.properties</code> where profile name can be <strong>dev, qa, staging</strong> and <strong>prod</strong>.
Then we just need to enable the desired profile for Spring Boot to read values from that
specific profile properties file.</p>
</div>
<div class="paragraph">
<p>Spring Boot is very flexible to customize those conventions based on our project needs and preferences.</p>
</div>
</div>
<div class="sect3">
<h4 id="dependency-version-management"><a class="anchor" href="#dependency-version-management"></a>1.1.3. Dependency Version Management</h4>
<div class="paragraph">
<p>Typically, Spring Boot applications inherit from <code>spring-boot-starter-parent</code> which is configured with
all the compatible library versions so that we don&#8217;t have to hunt for checking which library version
is compatible with which version of Spring.
We can check <code>pom.xml</code> of <code>org.springframework.boot:spring-boot-dependencies</code> module to see
what are all the libraries pre-configured.</p>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-monitoring-capabilities"><a class="anchor" href="#production-ready-monitoring-capabilities"></a>1.1.4. Production-Ready Monitoring Capabilities</h4>
<div class="paragraph">
<p>Monitoring is an important aspect of any application running in production. Spring Boot provides
production ready monitoring capabilities via Actuator.
We can get the application runtime information like <strong>Memory usage, Disk Space, HealthCheck of
various components</strong> etc via Actuator REST endpoints.
Actuator uses <strong>Micrometer</strong> under-the-hood which we can use to export all those application metrics
to various monitoring services like <strong>Prometheus, Datadog, Influx</strong> etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="embedded-servers-support"><a class="anchor" href="#embedded-servers-support"></a>1.1.5. Embedded Servers Support</h4>
<div class="paragraph">
<p>Traditionally, Java based web applications are built as <strong>war</strong> files and then deployed on a servlet containers
or application servers like <strong>Tomcat, Wildfly, WebSphere</strong> etc.
The modern approach is to embed the server runtime within the application itself so that
we can take the artifact(jar) and run it without having to install and configure server externally.</p>
</div>
<div class="paragraph">
<p>Spring Boot provides support for embedding servlet containers like <strong>Tomcat, Jetty, Undertow,</strong>
and we can customize various server properties in server-independent way.
Spring Boot provides various server-specific customization properties as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-ecosystem"><a class="anchor" href="#spring-ecosystem"></a>1.1.6. Spring Ecosystem</h4>
<div class="paragraph">
<p>Spring Boot has a huge ecosystem of projects to support wide verity of application types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>SpringMVC &amp; Spring WebFlux</strong>: We can build traditional web applications and REST APIs using
<strong>SpringMVC</strong> or non-blocking reactive applications using <strong>Spring WebFlux</strong>.</p>
</li>
<li>
<p><strong>Spring Data</strong>: Spring Data provides high-level abstraction over ORM and NoSQL data access libraries
so that we don&#8217;t need to implement boilerplate CRUD operations again and again.</p>
</li>
<li>
<p><strong>Spring Security</strong>: We can implement Authentication and Authorization using Spring Security.
It also supports implementing <strong>OAuth 2.0</strong> based security.</p>
</li>
<li>
<p><strong>Spring Batch</strong>: We can build robust batch applications using SpringBatch.</p>
</li>
<li>
<p><strong>Spring Integration</strong>: Spring Integration implements many of the <strong>Enterprise Integration Patterns</strong>
which we can use for integration with 3rd party services.</p>
</li>
<li>
<p><strong>Spring Cloud</strong>: Spring Cloud provides support for building Cloud Native applications following
<a href="https://12factor.net/">12 Factor Application</a> principles</p>
</li>
<li>
<p><strong>Spring Cloud Streams</strong>: We can build Data Pipelines for processing Stream based Data Sources like Kafka.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And, there are many more interesting projects. See <a href="https://spring.io/projects" class="bare">spring.io/projects</a> for more Spring ecosystem projects.</p>
</div>
<div class="paragraph">
<p>Okay, that&#8217;s enough of theory. Let&#8217;s get our hands dirty by doing the mandatory ritual :-)</p>
</div>
<div class="paragraph">
<p>Yes, you guessed it right. We are going to build a HelloWorld application using Spring Boot and
explore some of its features.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-with-spring-boot"><a class="anchor" href="#getting-started-with-spring-boot"></a>1.2. Getting Started with Spring Boot</h3>
<div class="paragraph">
<p>Spring Boot applications can be created either using <a href="https://start.spring.io/">Spring Initializr</a>
or <a href="https://spring.io/tools">Spring Tool Suite</a>
or <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA Ultimate</a>
or <a href="https://netbeans.apache.org/">NetBeans IDE</a> with
<a href="https://github.com/AlexFalappa/nb-springboot">Spring Boot Plugin</a>.</p>
</div>
<div class="paragraph">
<p>We are going to use <a href="https://start.spring.io/">Spring Initializr</a> and provide the following project metadata.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Project</strong>: Maven Project</p>
</li>
<li>
<p><strong>Language</strong>: Java</p>
</li>
<li>
<p><strong>Spring Boot</strong>: 3.2.3</p>
</li>
<li>
<p><strong>Project Metadata</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Group</strong>: com.sivalabs</p>
</li>
<li>
<p><strong>Artifact</strong>: spring-boot-helloworld</p>
</li>
<li>
<p><strong>Name</strong>: spring-boot-helloworld</p>
</li>
<li>
<p><strong>Description</strong>: Spring Boot HelloWorld</p>
</li>
<li>
<p><strong>Package name</strong>: com.sivalabs.helloworld</p>
</li>
<li>
<p><strong>Packaging</strong>: jar</p>
</li>
<li>
<p><strong>Java</strong>: 21</p>
</li>
</ul>
</div>
</li>
<li>
<p>Click on <strong>ADD DEPENDENCIES</strong> and add <strong>Spring Web</strong> starter.</p>
</li>
<li>
<p>Click on <strong>GENERATE</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated Spring Boot application will be downloaded. We can extract the zip file and
import the project into our IDE. I will be using IntelliJ IDEA, but you can use any of your favorite IDE.</p>
</div>
</div>
<div class="sect2">
<h3 id="simple-rest-api-using-spring-boot"><a class="anchor" href="#simple-rest-api-using-spring-boot"></a>1.3. Simple REST API using Spring Boot</h3>
<div class="paragraph">
<p>We are going to build a simple REST API with a single endpoint <strong>GET /api/hello?name={name}</strong> which returns
the JSON response <strong>{ "greeting" : "Hello {name}"}</strong>.
Also, we don&#8217;t want to hard-code the greeting prefix <strong>"Hello"</strong>, we want it to be configurable.</p>
</div>
<div class="paragraph">
<p>Let us start with creating response model class <code>GreetingResponse</code> as follows:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/sivalabs/helloworld/GreetingResponse.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.sivalabs.helloworld;

record GreetingResponse(String greeting){}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, create <code>ApplicationProperties</code> class to bind all the application configuration properties.</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/sivalabs/helloworld/ApplicationProperties.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package com.sivalabs.helloworld;

</span><span class="fold-block hide-when-folded">import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.bind.DefaultValue;

</span><span class="fold-block">@ConfigurationProperties(prefix = "app") <i class="conum" data-value="1"></i><b>(1)</b>
public record ApplicationProperties(
    @DefaultValue("Hello") String greeting,  <i class="conum" data-value="2"></i><b>(2)</b>
    @DefaultValue("World") String defaultName) {
}
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We are binding the properties in <code>application.properties</code> file with common prefix <code>"app."</code>
into <code>ApplicationProperties</code> fields.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We are using <code>@DefaultValue</code> annotation to provide default values for the properties.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Create <code>GreetingService</code> and implement <code>sayHello(String name)</code> method as follows:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/sivalabs/helloworld/GreetingService.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package com.sivalabs.helloworld;

</span><span class="fold-block hide-when-folded">import org.springframework.stereotype.Service;

</span><span class="fold-block">@Service <i class="conum" data-value="1"></i><b>(1)</b>
public class GreetingService {
    private final ApplicationProperties properties;

    public GreetingService(ApplicationProperties properties) { <i class="conum" data-value="2"></i><b>(2)</b>
        this.properties = properties;
    }

    public String sayHello(String name) {
        var s = name == null? properties.defaultName(): name;
        return String.format("%s %s", properties.greeting(), s);
    }
}
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare <code>GreetingService</code> as Spring bean using <code>@Service</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Injecting <code>ApplicationProperties</code> as a dependency of <code>GreetingService</code> bean.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Create <code>HelloWorldController</code> and implement the <code>GET /api/hello</code> API endpoint as follows:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/sivalabs/helloworld/HelloWorldController.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package com.sivalabs.helloworld;

</span><span class="fold-block hide-when-folded">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

</span><span class="fold-block">@RestController <i class="conum" data-value="1"></i><b>(1)</b>
class HelloWorldController {
    private static final Logger log =
            LoggerFactory.getLogger(HelloWorldController.class);
    private final GreetingService greetingService;

    HelloWorldController(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    @GetMapping("/api/hello") <i class="conum" data-value="2"></i><b>(2)</b>
    GreetingResponse sayHello(
            @RequestParam(name = "name", required = false) String name) {
        log.info("Say Hello to Name: {}", name);
        String greeting = greetingService.sayHello(name);
        return new GreetingResponse(greeting);
    }
}
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declares the class as Spring Controller with request handler methods.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>sayHello()</code> method is annotated with <code>@GetMapping("/api/hello")</code> indicating it as
a request handler method for <code>HTTP GET /api/hello</code> URL.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s configure the properties in <code>application.properties</code> as follows:</p>
</div>
<div class="listingblock">
<div class="title">src/main/resources/application.properties</div>
<div class="content">
<pre class="highlight"><code class="language-properties" data-lang="properties">app.greeting=Hello
app.default-name=World</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we need to enable the configuration properties binding using <code>@EnableConfigurationProperties</code> as follows:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/com/sivalabs/helloworld/SpringBootHelloWorldApplication.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package com.sivalabs.helloworld;

</span><span class="fold-block hide-when-folded">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

</span><span class="fold-block">@SpringBootApplication
@EnableConfigurationProperties({ApplicationProperties.class}) <i class="conum" data-value="1"></i><b>(1)</b>
//@ConfigurationPropertiesScan <i class="conum" data-value="2"></i><b>(2)</b>
public class SpringBootHelloWorldApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootHelloWorldApplication.class, args);
    }
}
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Explicitly enabling the configuration properties binding for <code>ApplicationProperties</code> class.
If we have more such configuration binding classes, we can list them all.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Instead of explicitly specifying all the configuration binding classes using <code>@EnableConfigurationProperties</code>
we can use <code>@ConfigurationPropertiesScan</code> annotation to scan for all the classes that are annotated
with <code>@ConfigurationProperties</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can run the application from IDE by simply running <code>main()</code> method in <code>SpringBootHelloWorldApplication</code>.</p>
</div>
<div class="paragraph">
<p>We can verify the API endpoint using cURL as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ curl http://localhost:8080/api/hello
{"greeting":"Hello World"}

$ curl http://localhost:8080/api/hello?name=Siva
{"greeting":"Hello Siva"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Congratulations!!!. We wrote our first Spring Boot application.</p>
</div>
</div>
<div class="sect2">
<h3 id="run-application-using-maven-and-gradle"><a class="anchor" href="#run-application-using-maven-and-gradle"></a>1.4. Run Application using Maven and Gradle</h3>
<div class="paragraph">
<p>Spring Boot provides Maven and Gradle plugins with the ability to run the application without having
to build the artifact (jar or war).</p>
</div>
<div class="paragraph">
<p>Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./mvnw spring-boot:run</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gradle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">./gradlew bootRun</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run-application-as-fatjar"><a class="anchor" href="#run-application-as-fatjar"></a>1.5. Run Application as FatJar</h3>
<div class="paragraph">
<p>We can build the Spring Boot application as a fat jar and run it using <code>java -jar</code> command.</p>
</div>
<div class="paragraph">
<p><strong>Maven:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ./mvnw clean package
$ java -jar target/spring-boot-helloworld-0.0.1-SNAPSHOT.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gradle:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ./gradlew clean build
$ java -jar build/libs/spring-boot-helloworld-0.0.1-SNAPSHOT.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we should be able to call API using <code>curl <a href="http://localhost:8080/api/hello" class="bare">localhost:8080/api/hello</a></code></p>
</div>
</div>
<div class="sect2">
<h3 id="run-application-as-docker-container"><a class="anchor" href="#run-application-as-docker-container"></a>1.6. Run Application as Docker Container</h3>
<div class="paragraph">
<p>Spring Boot Maven/Gradle Plugins provide the ability to build docker image using
<a href="https://buildpacks.io/">Cloud Native Buildpacks</a> without having to create <code>Dockerfile</code>.</p>
</div>
<div class="paragraph">
<p>Once we have Docker installed and running on our machine, we can build a Docker image of
our Spring Boot application using Spring Boot Maven/Gradle plugins as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">#Maven
$ ./mvnw spring-boot:build-image -Dspring-boot.build-image.imageName=YOUR_DOCKER_USERNAME/spring-boot-helloworld

#Gradle
$ ./gradlew bootBuildImage --imageName=YOUR_DOCKER_USERNAME/spring-boot-helloworld</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can start a container from the image and test the API endpoint as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ docker run -p 8080:8080 YOUR_DOCKER_USERNAME/spring-boot-helloworld -d
$ curl http://localhost:8080/api/hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more customization options, please refer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/">Spring Boot Maven Plugin</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/">Spring Boot Gradle Plugin</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://github.com/GoogleContainerTools/jib">Jib</a> is an alternative to building a container image
without requiring a Docker daemon running.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We have just scratched the surface of Spring Boot by quickly creating a simple REST API application
and running it in various ways.
We are going to explore all the underlying concepts of Spring Boot in detail in the upcoming chapters.</p>
</div>
</div>
<div class="sect2">
<h3 id="summary"><a class="anchor" href="#summary"></a>1.7. Summary</h3>
<div class="paragraph">
<p>In this chapter, we took a glance at what are the top features of Spring Boot,
and then we created a simple application. We learned how to implement a simple REST API endpoint.
Finally, we learned how to run application in various ways using
maven/gradle plugins, as a fat jar and as a docker container.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-quick-tour-of-spring-framework-core-concepts"><a class="anchor" href="#a-quick-tour-of-spring-framework-core-concepts"></a>2. A Quick Tour of Spring Framework Core Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot is an opinionated and convention over configuration based approach to building Spring powered applications.
So, all the Spring framework core concepts are still applicable in Spring Boot.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are familiar with the Spring framework, feel free to skip this chapter.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this chapter, we will take a quick tour of some of the Spring framework core concepts.</p>
</div>
<div class="sect2">
<h3 id="dependency-injection"><a class="anchor" href="#dependency-injection"></a>2.1. Dependency Injection</h3>
<div class="paragraph">
<p>One of the key concepts of the Spring framework is Dependency Injection (DI).</p>
</div>
<div class="paragraph">
<p>Dependency Injection is a design pattern that promotes loose coupling by externalizing the construction and
injection of an object&#8217;s dependencies. This makes the system more modular, testable, and easier to maintain.</p>
</div>
<div class="paragraph">
<p>For example, consider the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserService {
    private final UserRepository userRepository;

    // Constructor Injection
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // methods using userRepository
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the <code>UserService</code> class is dependent on the <code>UserRepository</code> class.
The <code>UserRepository</code> is injected into the <code>UserService</code> class using constructor injection.</p>
</div>
<div class="paragraph">
<p>Instead of creating the <code>UserRepository</code> object inside the <code>UserService</code> class,
the <code>UserRepository</code> object is injected into the <code>UserService</code> class from the outside.
Typically, the <code>UserRepository</code> object is constructed and injected by the Spring framework.</p>
</div>
<div class="paragraph">
<p>With this approach, we can replace the <code>UserRepository</code> object with a mock object for testing purposes.
This enables loose coupling and makes the system more modular and testable.</p>
</div>
<div class="paragraph">
<p>Spring provides different ways to achieve Dependency Injection:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Constructor Injection (recommended)</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Constructor injection is the most recommended way to inject dependencies in Spring.
All the required dependencies are passed as constructor arguments.
If there is only one constructor, the <code>@Autowired</code> annotation is optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // ...
}
</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Setter Injection</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Setter injection is another way to inject dependencies in Spring.
We can use the <code>@Autowired</code> annotation on the setter method to inject the dependency.
This approach is not recommended because it makes the class mutable and can lead to inconsistent states.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserService {
    private UserRepository userRepository;

    @Autowired
    public setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // ...
}
</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Field Injection (not recommended)</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The field injection is the least recommended way to inject dependencies in Spring.
We can use the <code>@Autowired</code> annotation on the field to inject the dependency.
This approach is not recommended because it makes the class tightly coupled and hard to test.
But usually, field injection is used in the tests to inject the dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserService {
    @Autowired
    private UserRepository userRepository;

    // ...
}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bean-registration"><a class="anchor" href="#bean-registration"></a>2.2. Bean Registration</h3>
<div class="paragraph">
<p>To let the Spring framework manage the lifecycle of an object, we need to register the class as a bean.
Spring framework supports several ways to register beans:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XML Configuration (legacy approach, not being used in modern applications)</p>
</li>
<li>
<p>Annotation-based Configuration</p>
</li>
<li>
<p>Java Configuration</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="annotation-based-configuration"><a class="anchor" href="#annotation-based-configuration"></a>2.2.1. Annotation-based Configuration</h4>
<div class="paragraph">
<p>In the annotation-based configuration, we can use the <code>@Component</code> annotation to register a class as a Spring bean.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class UserRepository {

    // methods
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // methods using userRepository
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the <code>UserRepository</code> and <code>UserService</code> classes are registered as Spring beans using the <code>@Component</code> annotation.
The <code>@Autowired</code> annotation is used to inject the <code>UserRepository</code> object into the <code>UserService</code> class.
But, if there is only one constructor in the class, the <code>@Autowired</code> annotation is optional.</p>
</div>
<div class="paragraph">
<p>The <code>@Component</code> annotation is a generic stereotype for any Spring-managed component.
We can also use more specific annotations like <code>@Service</code>, <code>@Repository</code>, and <code>@Controller</code> to register beans.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Controller</code> — for classes that handle HTTP requests</p>
</li>
<li>
<p><code>@Service</code> — for classes which perform business logic as a unit of work</p>
</li>
<li>
<p><code>@Repository</code> — for classes that access the database</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="java-configuration"><a class="anchor" href="#java-configuration"></a>2.2.2. Java Configuration</h4>
<div class="paragraph">
<p>In the Java configuration based approach, we can use the <code>@Configuration</code> annotation to define a class as a configuration class.
We can use the <code>@Bean</code> annotation to register a method as a bean.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public UserRepository userRepository() {
        return new UserRepository();
    }

    @Bean
    public UserService userService(UserRepository userRepository) {
        return new UserService(userRepository);
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the <code>AppConfig</code> class is defined as a configuration class using the <code>@Configuration</code> annotation.
The <code>userRepository</code> and <code>userService</code> methods are registered as beans using the <code>@Bean</code> annotation.
When the application starts, the Spring IoC container will create and manage the <code>UserRepository</code> and <code>UserService</code> beans.</p>
</div>
<div class="paragraph">
<p>While we can follow Java configuration for our own code too,
this approach is commonly used for registering beans from third-party libraries.
We can combine both annotation-based and Java configuration in the same application.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bean-scopes"><a class="anchor" href="#bean-scopes"></a>2.3. Bean Scopes</h3>
<div class="paragraph">
<p>In the Spring Framework, a bean is an object that is managed by the Spring IoC container.
Bean scopes define the lifecycle and visibility of a bean within the container.
Spring supports several bean scopes, each serving different purposes.
Here are the main Spring bean scopes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Singleton(default):</strong></p>
<div class="ulist">
<ul>
<li>
<p>a single instance of the bean is created for the entire application context.</p>
</li>
<li>
<p>It is the default scope for a Spring bean.</p>
</li>
<li>
<p>The same bean instance is returned whenever the bean is requested.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Prototype:</strong></p>
<div class="ulist">
<ul>
<li>
<p>In the prototype scope, a new bean instance is created every time it is requested.</p>
</li>
<li>
<p>It is suitable for stateful beans where a new instance is needed for each client or usage.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Request:</strong></p>
<div class="ulist">
<ul>
<li>
<p>The request scope is specific to web applications and creates a new bean instance for each HTTP request.</p>
</li>
<li>
<p>Suitable for beans that store temporary data related to a specific HTTP request.</p>
</li>
<li>
<p>It is available only in a web-aware Spring ApplicationContext.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Session:</strong></p>
<div class="ulist">
<ul>
<li>
<p>Similar to request scope, the session scope is specific to web applications and creates a new bean instance for each HTTP session.</p>
</li>
<li>
<p>Suitable for beans that store temporary data related to a specific user session.</p>
</li>
<li>
<p>Like request scope, it is available only in a web-aware Spring ApplicationContext.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Application:</strong></p>
<div class="ulist">
<ul>
<li>
<p>The application scope is specific to web applications and creates a single bean instance for the entire ServletContext.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>WebSocket:</strong></p>
<div class="ulist">
<ul>
<li>
<p>The WebSocket scope is specific to web applications and creates a new bean instance for each WebSocket session.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>Singleton Beans with Prototype-bean Dependencies</strong></p>
</div>
<div class="paragraph">
<p>When we use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved
at instantiation time. Thus, if we inject a prototype-scoped bean into a singleton-scoped bean,
a new prototype bean is instantiated and then dependency-injected into the singleton bean.
The prototype instance is the sole instance ever supplied to the singleton-scoped bean.</p>
</div>
<div class="paragraph">
<p>If we need to inject a new prototype instance into the singleton bean at runtime,
consider using <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection">Method Injection</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, consider the following bean registration with different scopes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    @Scope("prototype")
    public UserRepository userRepository() {
        return new UserRepository();
    }

    @Bean
    @Scope("singleton")
    public UserService userService(UserRepository userRepository) {
        return new UserService(userRepository);
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the <code>userRepository</code> bean is registered with the <strong>prototype</strong> scope,
and the <code>userService</code> bean is registered with the <strong>singleton</strong> scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.AnnotationConfigApplicationContext;

</span><span class="fold-block">public class MyApp {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(AppConfig.class);
        ctx.refresh();

        UserService svc1 = ctx.getBean(UserService.class);
        System.out.println(svc1.hashCode()); //123456
        UserService svc2 = ctx.getBean(UserService.class); // each time it will return the same instance
        System.out.println(svc2.hashCode()); //123456

        UserRepository repo1 = ctx.getBean(UserRepository.class);
        System.out.println(repo1.hashCode()); //7890123
        UserRepository repo2 = ctx.getBean(UserRepository.class); // each time it will return a new instance
        System.out.println(repo2.hashCode()); //5768493

        // However, UserService will hold the same instance of UserRepository dependency
        UserService svc3 = ctx.getBean(UserService.class);
        System.out.println(svc3.hashCode()); //123456
        System.out.println(svc3.getUserRepository().hashCode()); //567890
        UserService svc4 = ctx.getBean(UserService.class);
        System.out.println(svc4.hashCode()); //123456
        System.out.println(svc4.getUserRepository().hashCode()); //567890

        ctx.close();
    }
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Understanding the bean scopes is crucial for effective bean management and resource utilization.</p>
</div>
</div>
<div class="sect2">
<h3 id="bean-lifecycle-callbacks"><a class="anchor" href="#bean-lifecycle-callbacks"></a>2.4. Bean Lifecycle Callbacks</h3>
<div class="paragraph">
<p>In Spring, the lifecycle of a bean involves several phases, and Spring provides ways to hook into these phases
through lifecycle callback methods.
These methods allow us to perform custom actions during the initialization, and destruction of a bean.
The two main types of lifecycle callbacks in Spring are initialization callbacks and destruction callbacks.</p>
</div>
<div class="paragraph">
<p>We can use the JSR-250 annotations <code>@PostConstruct</code> and <code>@PreDestroy</code> to define
the initialization and destruction callbacks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;

</span><span class="fold-block">@Component
public class SampleBean {

    @PostConstruct
    public void init() {
        System.out.println("initialization logic");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("clean up logic");
    }
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>While using Java configuration, we can use the <code>@Bean</code> annotation to define the initialization and destruction callbacks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean(initMethod = "init", destroyMethod = "destroy")
    public SampleBean sampleBean() {
        return new SampleBean();
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also use the <code>InitializingBean</code> and <code>DisposableBean</code> interfaces to define the initialization and destruction callbacks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

</span><span class="fold-block">@Component
public class SampleBean implements InitializingBean, DisposableBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("initialization logic");
    }

    @Override
    public void destroy() {
        System.out.println("clean up logic");
    }
}
</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are recommended for implementing lifecycle callbacks
in a modern Spring application.
Using <code>InitializingBean</code>, <code>DisposableBean</code> will couple our code to Spring-specific interfaces.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aspect-oriented-programming-aop"><a class="anchor" href="#aspect-oriented-programming-aop"></a>2.5. Aspect Oriented Programming (AOP)</h3>
<div class="paragraph">
<p>Aspect-Oriented Programming (AOP) is a programming paradigm that aims to increase modularity by allowing
the separation of cross-cutting concerns. Cross-cutting concerns are aspects of a program that affect multiple modules
or components, such as logging, security, and transaction management.
AOP provides a way to modularize these concerns, making code more maintainable and less redundant.</p>
</div>
<div class="paragraph">
<p>In Spring Framework, AOP is used to separate concerns from the main business logic of an application.
Spring AOP is implemented using proxy patterns and allows us to define aspects (modules encapsulating cross-cutting concerns)
that can be applied to different parts of our application.</p>
</div>
<div class="paragraph">
<p>Here are some key concepts in Spring AOP:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Aspect:</strong> An aspect is a module that encapsulates a cross-cutting concern. It contains advice and can also include pointcuts
and other configurations. Examples of aspects include logging, transaction management, and security.</p>
</li>
<li>
<p><strong>Advice:</strong> Advice is the action taken by an aspect at a particular join point.
It represents the code that runs when a certain condition is met.
Types of advice in Spring AOP include "before," "after," "around," "after returning," and "after throwing."</p>
</li>
<li>
<p><strong>JoinPoint:</strong> A join point is a point during the execution of a program where an aspect&#8217;s advice can be applied.
In Spring AOP, join points are typically method executions.</p>
</li>
<li>
<p><strong>Pointcut:</strong> A pointcut is a set of one or more join points where advice should be executed.
It defines a condition for matching join points.
Pointcuts enable us to specify where in our codebase an aspect&#8217;s advice should be applied.</p>
</li>
<li>
<p><strong>AspectJ Annotation Support:</strong> Spring AOP supports AspectJ-style annotations for defining aspects, advice, and pointcuts.
Annotations like <code>@Aspect</code>, <code>@Before</code>, <code>@After</code>, and <code>@Around</code> make it easier to define aspects
in a more concise and readable manner.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here&#8217;s a simple example to illustrate Spring AOP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethodExecution() {
        System.out.println("Logging: Method is about to be executed");
    }
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the <code>LoggingAspect</code> class defines an aspect with a <code>@Before</code> advice that will be executed
before the execution of any method in the <code>com.example.service</code> package.</p>
</div>
</div>
<div class="sect2">
<h3 id="summary-2"><a class="anchor" href="#summary-2"></a>2.6. Summary</h3>
<div class="paragraph">
<p>In this chapter, we took a quick tour of the Spring framework core concepts.
We learned about <strong>Dependency Injection</strong>, <strong>Bean Registration</strong>, <strong>Bean Scopes</strong>, <strong>Bean Lifecycle Callbacks</strong>
and <strong>Aspect-Oriented Programming (AOP)</strong>.
These concepts are fundamental to understanding the Spring framework and are still valid in Spring Boot.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-06-22 18:50:52 +0530
</div>
</div>
</div>
  </div>
</div>
</body>
</html>